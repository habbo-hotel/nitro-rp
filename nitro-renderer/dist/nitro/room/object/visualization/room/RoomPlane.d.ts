import { RenderTexture, Resource, Texture } from '@pixi/core';
import { Point } from '@pixi/math';
import { IRoomGeometry, IRoomPlane, IVector3D } from '../../../../../api';
import { PlaneTextureCache } from '../../../../../pixi-proxy';
import { PlaneMaskManager } from './mask';
import { PlaneDrawingData } from './PlaneDrawingData';
import { IPlaneRasterizer } from './rasterizer';
export declare class RoomPlane implements IRoomPlane {
    private static ZERO_POINT;
    static TYPE_UNDEFINED: number;
    static TYPE_WALL: number;
    static TYPE_FLOOR: number;
    static TYPE_LANDSCAPE: number;
    private static _uniqueIdCounter;
    private _textureCache;
    private _disposed;
    private _randomSeed;
    private _origin;
    private _location;
    private _leftSide;
    private _rightSide;
    private _normal;
    private _secondaryNormals;
    private _geometryUpdateId;
    private _type;
    private _isVisible;
    private _bitmapData;
    private _hasTexture;
    private _offset;
    private _relativeDepth;
    private _color;
    private _rasterizer;
    private _maskManager;
    private _id;
    private _uniqueId;
    private _textureOffsetX;
    private _textureOffsetY;
    private _textureMaxX;
    private _textureMaxY;
    private _activeTexture;
    private _useMask;
    private _bitmapMasks;
    private _rectangleMasks;
    private _maskChanged;
    private _maskBitmapData;
    private _maskPixels;
    private _bitmapMasksOld;
    private _rectangleMasksOld;
    private _cornerA;
    private _cornerB;
    private _cornerC;
    private _cornerD;
    private _width;
    private _height;
    private _canBeVisible;
    constructor(textureCache: PlaneTextureCache, origin: IVector3D, location: IVector3D, leftSide: IVector3D, rightSide: IVector3D, type: number, usesMask: boolean, secondaryNormals: IVector3D[], randomSeed: number, textureOffsetX?: number, textureOffsetY?: number, textureMaxX?: number, textureMaxY?: number);
    private static blend;
    set canBeVisible(k: boolean);
    get canBeVisible(): boolean;
    get bitmapData(): Texture<Resource>;
    get maskBitmapData(): RenderTexture;
    get visible(): boolean;
    get offset(): Point;
    get relativeDepth(): number;
    get color(): number;
    set color(k: number);
    get type(): number;
    get leftSide(): IVector3D;
    get rightSide(): IVector3D;
    get location(): IVector3D;
    get normal(): IVector3D;
    get hasTexture(): boolean;
    set hasTexture(k: boolean);
    set rasterizer(k: IPlaneRasterizer);
    set maskManager(k: PlaneMaskManager);
    set id(k: string);
    get uniqueId(): number;
    dispose(): void;
    copyBitmapData(k: Texture<Resource>): Texture<Resource>;
    private resetTextureCache;
    private getTextureIdentifier;
    private needsNewTexture;
    private getTexture;
    private resolveMasks;
    private screenWidth;
    getDrawingDatas(geometry: IRoomGeometry): PlaneDrawingData[];
    update(geometry: IRoomGeometry, timeSinceStartMs: number): boolean;
    private updateCorners;
    private getMatrixForDimensions;
    private renderTexture;
    private draw;
    resetBitmapMasks(): void;
    addBitmapMask(maskType: string, leftSideLoc: number, rightSideLoc: number): boolean;
    resetRectangleMasks(): void;
    addRectangleMask(k: number, _arg_2: number, _arg_3: number, _arg_4: number): boolean;
    private updateMaskChangeStatus;
    private updateMask;
    private combineTextureMask;
}
