import { RenderTexture } from '@pixi/core';
import { Sprite } from '@pixi/sprite';
import { IActiveActionData, IAnimationLayerData, IAvatarDataContainer, IAvatarEffectListener, IAvatarFigureContainer, IAvatarImage, IGraphicAsset, IPartColor, ISpriteDataContainer } from '../../api';
import { ActiveActionData } from './actions';
import { AssetAliasCollection } from './alias';
import { AvatarFigureContainer } from './AvatarFigureContainer';
import { AvatarStructure } from './AvatarStructure';
import { AvatarImageCache } from './cache';
import { EffectAssetDownloadManager } from './EffectAssetDownloadManager';
export declare class AvatarImage implements IAvatarImage, IAvatarEffectListener {
    private static CHANNELS_EQUAL;
    private static CHANNELS_UNIQUE;
    private static CHANNELS_RED;
    private static CHANNELS_GREEN;
    private static CHANNELS_BLUE;
    private static CHANNELS_DESATURATED;
    private static DEFAULT_ACTION;
    private static DEFAULT_DIRECTION;
    private static DEFAULT_AVATAR_SET;
    protected _structure: AvatarStructure;
    protected _scale: string;
    protected _mainDirection: number;
    protected _headDirection: number;
    protected _mainAction: IActiveActionData;
    protected _disposed: boolean;
    protected _canvasOffsets: number[];
    protected _assets: AssetAliasCollection;
    protected _cache: AvatarImageCache;
    protected _figure: AvatarFigureContainer;
    protected _avatarSpriteData: IAvatarDataContainer;
    protected _actions: ActiveActionData[];
    protected _image: RenderTexture;
    protected _reusableTexture: RenderTexture;
    private _defaultAction;
    private _frameCounter;
    private _directionOffset;
    private _changes;
    private _sprites;
    private _isAnimating;
    private _animationHasResetOnToggle;
    private _actionsSorted;
    private _sortedActions;
    private _lastActionsString;
    private _currentActionsString;
    private _fullImageCache;
    private _fullImageCacheSize;
    protected _isCachedImage: boolean;
    private _useFullImageCache;
    private _effectIdInUse;
    private _animationFrameCount;
    private _cachedBodyParts;
    private _cachedBodyPartsDirection;
    private _cachedBodyPartsGeometryType;
    private _cachedBodyPartsAvatarSet;
    private _effectManager;
    private _effectListener;
    constructor(k: AvatarStructure, _arg_2: AssetAliasCollection, _arg_3: AvatarFigureContainer, _arg_4: string, _arg_5: EffectAssetDownloadManager, _arg_6?: IAvatarEffectListener);
    getServerRenderData(): any[];
    dispose(): void;
    get disposed(): boolean;
    getFigure(): IAvatarFigureContainer;
    getScale(): string;
    getPartColor(k: string): IPartColor;
    setDirection(k: string, _arg_2: number): void;
    setDirectionAngle(k: string, _arg_2: number): void;
    getSprites(): ISpriteDataContainer[];
    getCanvasOffsets(): number[];
    getLayerData(k: ISpriteDataContainer): IAnimationLayerData;
    updateAnimationByFrames(k?: number): void;
    resetAnimationFrameCounter(): void;
    private getFullImageCacheKey;
    private getBodyParts;
    getAvatarPartsForCamera(k: string): void;
    getImage(setType: string, hightlight: boolean, scale?: number, cache?: boolean): RenderTexture;
    applyPalette(texture: RenderTexture, reds?: number[], greens?: number[], blues?: number[]): RenderTexture;
    getImageAsSprite(setType: string, scale?: number): Sprite;
    getCroppedImage(setType: string, scale?: number): HTMLImageElement;
    protected getFullImage(k: string): RenderTexture;
    protected cacheFullImage(k: string, _arg_2: RenderTexture): void;
    getAsset(k: string): IGraphicAsset;
    getDirection(): number;
    initActionAppends(): void;
    endActionAppends(): void;
    appendAction(k: string, ..._args: any[]): boolean;
    protected addActionData(k: string, _arg_2?: string): void;
    isAnimating(): boolean;
    private resetActions;
    private isHeadTurnPreventedByAction;
    private sortActions;
    private setActionsToParts;
    private setActionToParts;
    private resetBodyPartCache;
    get avatarSpriteData(): IAvatarDataContainer;
    private convertToGrayscale;
    private errorThis;
    private logThis;
    isPlaceholder(): boolean;
    forceActionUpdate(): void;
    get animationHasResetOnToggle(): boolean;
    get mainAction(): string;
    resetEffect(effect: number): void;
}
