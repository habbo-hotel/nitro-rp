import {
  Graphics
} from "./chunk-VJ33EA6C.js";
import "./chunk-A42R54TZ.js";
import "./chunk-AFWUENJS.js";
import "./chunk-NMEPII5P.js";
import "./chunk-6F3JVGAM.js";
import "./chunk-MQYHZ4VI.js";
import "./chunk-GCCTLPNP.js";
import {
  PI_2,
  Polygon
} from "./chunk-GM7ILVO6.js";
import "./chunk-UXIASGQL.js";

// ../node_modules/.pnpm/@pixi+graphics-extras@6.5.10_@pixi+graphics@6.5.10_@pixi+math@6.5.10/node_modules/@pixi/graphics-extras/dist/esm/graphics-extras.mjs
function drawTorus(x, y, innerRadius, outerRadius, startArc, endArc) {
  if (startArc === void 0) {
    startArc = 0;
  }
  if (endArc === void 0) {
    endArc = Math.PI * 2;
  }
  if (Math.abs(endArc - startArc) >= Math.PI * 2) {
    return this.drawCircle(x, y, outerRadius).beginHole().drawCircle(x, y, innerRadius).endHole();
  }
  this.finishPoly();
  this.arc(x, y, innerRadius, endArc, startArc, true).arc(x, y, outerRadius, startArc, endArc, false).finishPoly();
  return this;
}
function drawChamferRect(x, y, width, height, chamfer) {
  if (chamfer <= 0) {
    return this.drawRect(x, y, width, height);
  }
  var inset = Math.min(chamfer, Math.min(width, height) / 2);
  var right = x + width;
  var bottom = y + height;
  var points = [
    x + inset,
    y,
    right - inset,
    y,
    right,
    y + inset,
    right,
    bottom - inset,
    right - inset,
    bottom,
    x + inset,
    bottom,
    x,
    bottom - inset,
    x,
    y + inset
  ];
  for (var i = points.length - 1; i >= 2; i -= 2) {
    if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {
      points.splice(i - 1, 2);
    }
  }
  return this.drawPolygon(points);
}
function drawFilletRect(x, y, width, height, fillet) {
  if (fillet === 0) {
    return this.drawRect(x, y, width, height);
  }
  var maxFillet = Math.min(width, height) / 2;
  var inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
  var right = x + width;
  var bottom = y + height;
  var dir = inset < 0 ? -inset : 0;
  var size = Math.abs(inset);
  return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();
}
function drawRegularPolygon(x, y, radius, sides, rotation) {
  if (rotation === void 0) {
    rotation = 0;
  }
  sides = Math.max(sides | 0, 3);
  var startAngle = -1 * Math.PI / 2 + rotation;
  var delta = Math.PI * 2 / sides;
  var polygon = [];
  for (var i = 0; i < sides; i++) {
    var angle = i * delta + startAngle;
    polygon.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
  }
  return this.drawPolygon(polygon);
}
function drawRoundedPolygon(x, y, radius, sides, corner, rotation) {
  if (rotation === void 0) {
    rotation = 0;
  }
  sides = Math.max(sides | 0, 3);
  if (corner <= 0) {
    return this.drawRegularPolygon(x, y, radius, sides, rotation);
  }
  var sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
  corner = Math.min(corner, sideLength);
  var startAngle = -1 * Math.PI / 2 + rotation;
  var delta = Math.PI * 2 / sides;
  var internalAngle = (sides - 2) * Math.PI / sides / 2;
  for (var i = 0; i < sides; i++) {
    var angle = i * delta + startAngle;
    var x0 = x + radius * Math.cos(angle);
    var y0 = y + radius * Math.sin(angle);
    var a1 = angle + Math.PI + internalAngle;
    var a2 = angle - Math.PI - internalAngle;
    var x1 = x0 + corner * Math.cos(a1);
    var y1 = y0 + corner * Math.sin(a1);
    var x3 = x0 + corner * Math.cos(a2);
    var y3 = y0 + corner * Math.sin(a2);
    if (i === 0) {
      this.moveTo(x1, y1);
    } else {
      this.lineTo(x1, y1);
    }
    this.quadraticCurveTo(x0, y0, x3, y3);
  }
  return this.closePath();
}
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var Star = (
  /** @class */
  function(_super) {
    __extends(Star2, _super);
    function Star2(x, y, points, radius, innerRadius, rotation) {
      if (rotation === void 0) {
        rotation = 0;
      }
      var _this = this;
      innerRadius = innerRadius || radius / 2;
      var startAngle = -1 * Math.PI / 2 + rotation;
      var len = points * 2;
      var delta = PI_2 / len;
      var polygon = [];
      for (var i = 0; i < len; i++) {
        var r = i % 2 ? innerRadius : radius;
        var angle = i * delta + startAngle;
        polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));
      }
      _this = _super.call(this, polygon) || this;
      return _this;
    }
    return Star2;
  }(Polygon)
);
function drawStar(x, y, points, radius, innerRadius, rotation) {
  if (rotation === void 0) {
    rotation = 0;
  }
  return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation));
}
Object.defineProperties(Graphics.prototype, {
  drawTorus: { value: drawTorus },
  drawChamferRect: { value: drawChamferRect },
  drawFilletRect: { value: drawFilletRect },
  drawRegularPolygon: { value: drawRegularPolygon },
  drawRoundedPolygon: { value: drawRoundedPolygon },
  drawStar: { value: drawStar }
});
/*! Bundled license information:

@pixi/graphics-extras/dist/esm/graphics-extras.mjs:
  (*!
   * @pixi/graphics-extras - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/graphics-extras is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@pixi_graphics-extras.js.map
