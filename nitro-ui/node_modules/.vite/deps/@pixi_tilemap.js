import {
  Bounds,
  Container
} from "./chunk-A42R54TZ.js";
import {
  BaseTexture,
  Buffer,
  Geometry,
  ObjectRenderer,
  Program,
  Renderer,
  Resource,
  Shader,
  Texture
} from "./chunk-AFWUENJS.js";
import "./chunk-NMEPII5P.js";
import {
  createIndicesForQuads
} from "./chunk-6F3JVGAM.js";
import "./chunk-MQYHZ4VI.js";
import {
  ALPHA_MODES,
  DRAW_MODES,
  SCALE_MODES,
  WRAP_MODES
} from "./chunk-GCCTLPNP.js";
import {
  Matrix,
  groupD8
} from "./chunk-GM7ILVO6.js";
import "./chunk-UXIASGQL.js";

// ../node_modules/.pnpm/@pixi+tilemap@3.2.2_@pixi+constants@6.5.10_@pixi+core@6.5.10_@pixi+display@6.5.10_@pixi+graph_ufgxjx4z53dwjrj23rcpp7fpn4/node_modules/@pixi/tilemap/lib/pixi-tilemap.es.js
var CanvasTileRenderer = class _CanvasTileRenderer {
  /** The renderer */
  /** The global tile animation state */
  __init() {
    this.tileAnim = [0, 0];
  }
  /** @deprecated */
  __init2() {
    this.dontUseTransform = false;
  }
  /** @param renderer */
  constructor(renderer) {
    _CanvasTileRenderer.prototype.__init.call(this);
    _CanvasTileRenderer.prototype.__init2.call(this);
    this.renderer = renderer;
    this.tileAnim = [0, 0];
  }
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  static getInstance(renderer) {
    if (!renderer.plugins.tilemap) {
      renderer.plugins.tilemap = new _CanvasTileRenderer(renderer);
    }
    return renderer.plugins.tilemap;
  }
};
var settings = {
  /** The default number of textures per tilemap in a tilemap composite. */
  TEXTURES_PER_TILEMAP: 16,
  /**
   * The width/height of each texture tile in a {@link TEXTILE_DIMEN}. This is 1024px by default.
   *
   * This should fit all tile base-textures; otherwise, {@link TextileResource} may fail to correctly
   * upload the textures togther in a tiled fashion.
   */
  TEXTILE_DIMEN: 1024,
  /**
   * The number of texture tiles per {@link TextileResource}.
   *
   * Texture tiling is disabled by default, and so this is set to `1` by default. If it is set to a
   * higher value, textures will be uploaded together in a tiled fashion.
   *
   * Since {@link TextileResource} is a dual-column format, this should be even for packing
   * efficiency. The optimal value is usually 4.
   */
  TEXTILE_UNITS: 1,
  /** The scaling mode of the combined texture tiling. */
  TEXTILE_SCALE_MODE: SCALE_MODES.LINEAR,
  /** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */
  use32bitIndex: false,
  /** Flags whether textiles should be cleared when each tile is uploaded. */
  DO_CLEAR: true,
  // Backward compatibility
  get maxTextures() {
    return this.MAX_TEXTURES;
  },
  set maxTextures(value) {
    this.MAX_TEXTURES = value;
  },
  get boundSize() {
    return this.TEXTURE_TILE_DIMEN;
  },
  set boundSize(value) {
    this.TILE_TEXTURE_DIMEN = value;
  },
  get boundCountPerBuffer() {
    return this.TEXTILE_UNITS;
  },
  set boundCountPerBuffer(value) {
    this.TEXTILE_UNITS = value;
  }
};
var Constant = settings;
function _nullishCoalesce(lhs, rhsFn) {
  if (lhs != null) {
    return lhs;
  } else {
    return rhsFn();
  }
}
var POINT_STRUCT;
(function(POINT_STRUCT2) {
  const U = 0;
  POINT_STRUCT2[POINT_STRUCT2["U"] = U] = "U";
  const V = U + 1;
  POINT_STRUCT2[POINT_STRUCT2["V"] = V] = "V";
  const X = V + 1;
  POINT_STRUCT2[POINT_STRUCT2["X"] = X] = "X";
  const Y = X + 1;
  POINT_STRUCT2[POINT_STRUCT2["Y"] = Y] = "Y";
  const TILE_WIDTH = Y + 1;
  POINT_STRUCT2[POINT_STRUCT2["TILE_WIDTH"] = TILE_WIDTH] = "TILE_WIDTH";
  const TILE_HEIGHT = TILE_WIDTH + 1;
  POINT_STRUCT2[POINT_STRUCT2["TILE_HEIGHT"] = TILE_HEIGHT] = "TILE_HEIGHT";
  const ROTATE = TILE_HEIGHT + 1;
  POINT_STRUCT2[POINT_STRUCT2["ROTATE"] = ROTATE] = "ROTATE";
  const ANIM_X = ROTATE + 1;
  POINT_STRUCT2[POINT_STRUCT2["ANIM_X"] = ANIM_X] = "ANIM_X";
  const ANIM_Y = ANIM_X + 1;
  POINT_STRUCT2[POINT_STRUCT2["ANIM_Y"] = ANIM_Y] = "ANIM_Y";
  const TEXTURE_INDEX = ANIM_Y + 1;
  POINT_STRUCT2[POINT_STRUCT2["TEXTURE_INDEX"] = TEXTURE_INDEX] = "TEXTURE_INDEX";
  const ANIM_COUNT_X = TEXTURE_INDEX + 1;
  POINT_STRUCT2[POINT_STRUCT2["ANIM_COUNT_X"] = ANIM_COUNT_X] = "ANIM_COUNT_X";
  const ANIM_COUNT_Y = ANIM_COUNT_X + 1;
  POINT_STRUCT2[POINT_STRUCT2["ANIM_COUNT_Y"] = ANIM_COUNT_Y] = "ANIM_COUNT_Y";
  const ANIM_DIVISOR = ANIM_COUNT_Y + 1;
  POINT_STRUCT2[POINT_STRUCT2["ANIM_DIVISOR"] = ANIM_DIVISOR] = "ANIM_DIVISOR";
  const ALPHA = ANIM_DIVISOR + 1;
  POINT_STRUCT2[POINT_STRUCT2["ALPHA"] = ALPHA] = "ALPHA";
})(POINT_STRUCT || (POINT_STRUCT = {}));
var POINT_STRUCT_SIZE = Object.keys(POINT_STRUCT).length / 2;
var Tilemap = class _Tilemap extends Container {
  __init() {
    this.shadowColor = new Float32Array([0, 0, 0, 0.5]);
  }
  __init2() {
    this._globalMat = null;
  }
  /**
   * The tile animation frame.
   *
   * @see CompositeTilemap.tileAnim
   */
  __init3() {
    this.tileAnim = null;
  }
  /**
   * This is the last uploaded size of the tilemap geometry.
   * @ignore
   */
  __init4() {
    this.modificationMarker = 0;
  }
  /** @ignore */
  __init5() {
    this.offsetX = 0;
  }
  /** @ignore */
  __init6() {
    this.offsetY = 0;
  }
  /** @ignore */
  __init7() {
    this.compositeParent = false;
  }
  /**
   * The list of base-textures being used in the tilemap.
   *
   * This should not be shuffled after tiles have been added into this tilemap. Usually, only tile textures
   * should be added after tiles have been added into the map.
   */
  /**
   * The local bounds of the tilemap itself. This does not include DisplayObject children.
   */
  __init8() {
    this.tilemapBounds = new Bounds();
  }
  /** Flags whether any animated tile was added. */
  __init9() {
    this.hasAnimatedTile = false;
  }
  /** The interleaved geometry of the tilemap. */
  __init10() {
    this.pointsBuf = [];
  }
  /**
   * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The
   *      base-textures in this array must not be duplicated.
   */
  constructor(tileset) {
    super();
    _Tilemap.prototype.__init.call(this);
    _Tilemap.prototype.__init2.call(this);
    _Tilemap.prototype.__init3.call(this);
    _Tilemap.prototype.__init4.call(this);
    _Tilemap.prototype.__init5.call(this);
    _Tilemap.prototype.__init6.call(this);
    _Tilemap.prototype.__init7.call(this);
    _Tilemap.prototype.__init8.call(this);
    _Tilemap.prototype.__init9.call(this);
    _Tilemap.prototype.__init10.call(this);
    _Tilemap.prototype.__init11.call(this);
    _Tilemap.prototype.__init12.call(this);
    _Tilemap.prototype.__init13.call(this);
    _Tilemap.prototype.__init14.call(this);
    _Tilemap.prototype.__init15.call(this);
    _Tilemap.prototype.__init16.call(this);
    this.setTileset(tileset);
  }
  /**
   * @returns The tileset of this tilemap.
   */
  getTileset() {
    return this.tileset;
  }
  /**
   * Define the tileset used by the tilemap.
   *
   * @param tileset - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will
   *  be wrapped into an array. This should not contain any duplicates.
   */
  setTileset(tileset = []) {
    if (!Array.isArray(tileset)) {
      tileset = [tileset];
    }
    for (let i = 0; i < tileset.length; i++) {
      if (tileset[i].baseTexture) {
        tileset[i] = tileset[i].baseTexture;
      }
    }
    this.tileset = tileset;
    return this;
  }
  /**  Clears all the tiles added into this tilemap. */
  clear() {
    this.pointsBuf.length = 0;
    this.modificationMarker = 0;
    this.tilemapBounds.clear();
    this.hasAnimatedTile = false;
    return this;
  }
  /**
   * Adds a tile that paints the given texture at (x, y).
   *
   * @param tileTexture - The tiling texture to render.
   * @param x - The local x-coordinate of the tile's position.
   * @param y - The local y-coordinate of the tile's position.
   * @param options - Additional tile options.
   * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.
   * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.
   * @param [options.tileWidth=texture.orig.width] - The local width of the tile.
   * @param [options.tileHeight=texture.orig.height] - The local height of the tile.
   * @param [options.animX=0] - For animated tiles, this is the "offset" along the x-axis for adjacent
   *      animation frame textures in the base-texture.
   * @param [options.animY=0] - For animated tiles, this is the "offset" along the y-axis for adjacent
   *      animation frames textures in the base-texture.
   * @param [options.rotate=0]
   * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures
   *      per row.
   * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures
   *      per column.
   * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame
   * @param [options.alpha=1] - Tile alpha
   * @return This tilemap, good for chaining.
   */
  tile(tileTexture, x, y, options = {}) {
    let baseTexture;
    let textureIndex = -1;
    if (typeof tileTexture === "number") {
      textureIndex = tileTexture;
      baseTexture = this.tileset[textureIndex];
    } else {
      let texture;
      if (typeof tileTexture === "string") {
        texture = Texture.from(tileTexture);
      } else {
        texture = tileTexture;
      }
      const textureList = this.tileset;
      for (let i = 0; i < textureList.length; i++) {
        if (textureList[i] === texture.castToBaseTexture()) {
          textureIndex = i;
          break;
        }
      }
      if ("baseTexture" in texture) {
        options.u = _nullishCoalesce(options.u, () => texture.frame.x);
        options.v = _nullishCoalesce(options.v, () => texture.frame.y);
        options.tileWidth = _nullishCoalesce(options.tileWidth, () => texture.orig.width);
        options.tileHeight = _nullishCoalesce(options.tileHeight, () => texture.orig.height);
      }
      baseTexture = texture.castToBaseTexture();
    }
    if (!baseTexture || textureIndex < 0) {
      console.error("The tile texture was not found in the tilemap tileset.");
      return this;
    }
    const {
      u = 0,
      v = 0,
      tileWidth = baseTexture.realWidth,
      tileHeight = baseTexture.realHeight,
      animX = 0,
      animY = 0,
      rotate = 0,
      animCountX = 1024,
      animCountY = 1024,
      animDivisor = 1,
      alpha = 1
    } = options;
    const pb = this.pointsBuf;
    this.hasAnimatedTile = this.hasAnimatedTile || animX > 0 || animY > 0;
    pb.push(u);
    pb.push(v);
    pb.push(x);
    pb.push(y);
    pb.push(tileWidth);
    pb.push(tileHeight);
    pb.push(rotate);
    pb.push(animX | 0);
    pb.push(animY | 0);
    pb.push(textureIndex);
    pb.push(animCountX);
    pb.push(animCountY);
    pb.push(animDivisor);
    pb.push(alpha);
    this.tilemapBounds.addFramePad(x, y, x + tileWidth, y + tileHeight, 0, 0);
    return this;
  }
  /** Changes the rotation of the last tile. */
  tileRotate(rotate) {
    const pb = this.pointsBuf;
    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.TEXTURE_INDEX)] = rotate;
  }
  /** Changes the `animX`, `animCountX` of the last tile. */
  tileAnimX(offset, count) {
    const pb = this.pointsBuf;
    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_X)] = offset;
    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_X)] = count;
  }
  /** Changes the `animY`, `animCountY` of the last tile. */
  tileAnimY(offset, count) {
    const pb = this.pointsBuf;
    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_Y)] = offset;
    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_Y)] = count;
  }
  /** Changes the `animDivisor` value of the last tile. */
  tileAnimDivisor(divisor) {
    const pb = this.pointsBuf;
    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = divisor;
  }
  tileAlpha(alpha) {
    const pb = this.pointsBuf;
    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ALPHA)] = alpha;
  }
  __init11() {
    this.renderCanvas = (renderer) => {
      const plugin = CanvasTileRenderer.getInstance(renderer);
      if (plugin && !plugin.dontUseTransform) {
        const wt = this.worldTransform;
        renderer.context.setTransform(
          wt.a,
          wt.b,
          wt.c,
          wt.d,
          wt.tx * renderer.resolution,
          wt.ty * renderer.resolution
        );
      }
      this.renderCanvasCore(renderer);
    };
  }
  renderCanvasCore(renderer) {
    if (this.tileset.length === 0)
      return;
    const points = this.pointsBuf;
    const tileAnim = this.tileAnim || renderer.plugins.tilemap && renderer.plugins.tilemap.tileAnim;
    renderer.context.fillStyle = "#000000";
    for (let i = 0, n = points.length; i < n; i += POINT_STRUCT_SIZE) {
      let x1 = points[i + POINT_STRUCT.U];
      let y1 = points[i + POINT_STRUCT.V];
      const x2 = points[i + POINT_STRUCT.X];
      const y2 = points[i + POINT_STRUCT.Y];
      const w = points[i + POINT_STRUCT.TILE_WIDTH];
      const h = points[i + POINT_STRUCT.TILE_HEIGHT];
      x1 += points[i + POINT_STRUCT.ANIM_X] * tileAnim[0];
      y1 += points[i + POINT_STRUCT.ANIM_Y] * tileAnim[1];
      const textureIndex = points[i + POINT_STRUCT.TEXTURE_INDEX];
      const alpha = points[i + POINT_STRUCT.ALPHA];
      if (textureIndex >= 0 && this.tileset[textureIndex]) {
        renderer.context.globalAlpha = alpha;
        renderer.context.drawImage(
          this.tileset[textureIndex].getDrawableSource(),
          x1,
          y1,
          w,
          h,
          x2,
          y2,
          w,
          h
        );
      } else {
        renderer.context.globalAlpha = 0.5;
        renderer.context.fillRect(x2, y2, w, h);
      }
      renderer.context.globalAlpha = 1;
    }
  }
  __init12() {
    this.vbId = 0;
  }
  __init13() {
    this.vb = null;
  }
  __init14() {
    this.vbBuffer = null;
  }
  __init15() {
    this.vbArray = null;
  }
  __init16() {
    this.vbInts = null;
  }
  destroyVb() {
    if (this.vb) {
      this.vb.destroy();
      this.vb = null;
    }
  }
  render(renderer) {
    const plugin = renderer.plugins.tilemap;
    const shader = plugin.getShader();
    renderer.batch.setObjectRenderer(plugin);
    this._globalMat = shader.uniforms.projTransMatrix;
    renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);
    shader.uniforms.shadowColor = this.shadowColor;
    shader.uniforms.animationFrame = this.tileAnim || plugin.tileAnim;
    this.renderWebGLCore(renderer, plugin);
  }
  renderWebGLCore(renderer, plugin) {
    const points = this.pointsBuf;
    if (points.length === 0)
      return;
    const rectsCount = points.length / POINT_STRUCT_SIZE;
    const shader = plugin.getShader();
    const textures = this.tileset;
    if (textures.length === 0)
      return;
    plugin.bindTileTextures(renderer, textures);
    renderer.shader.bind(shader, false);
    let vb = this.vb;
    if (!vb) {
      vb = plugin.createVb();
      this.vb = vb;
      this.vbId = vb.id;
      this.vbBuffer = null;
      this.modificationMarker = 0;
    }
    plugin.checkIndexBuffer(rectsCount, vb);
    const boundCountPerBuffer = settings.TEXTILE_UNITS;
    const vertexBuf = vb.getBuffer("aVertexPosition");
    const vertices = rectsCount * vb.vertPerQuad;
    if (vertices === 0)
      return;
    if (this.modificationMarker !== vertices) {
      this.modificationMarker = vertices;
      const vs = vb.stride * vertices;
      if (!this.vbBuffer || this.vbBuffer.byteLength < vs) {
        let bk = vb.stride;
        while (bk < vs) {
          bk *= 2;
        }
        this.vbBuffer = new ArrayBuffer(bk);
        this.vbArray = new Float32Array(this.vbBuffer);
        this.vbInts = new Uint32Array(this.vbBuffer);
        vertexBuf.update(this.vbBuffer);
      }
      const arr = this.vbArray;
      let sz = 0;
      let textureId = 0;
      let shiftU = this.offsetX;
      let shiftV = this.offsetY;
      for (let i = 0; i < points.length; i += POINT_STRUCT_SIZE) {
        const eps = 0.5;
        if (this.compositeParent) {
          const textureIndex = points[i + POINT_STRUCT.TEXTURE_INDEX];
          if (boundCountPerBuffer > 1) {
            textureId = textureIndex >> 2;
            shiftU = this.offsetX * (textureIndex & 1);
            shiftV = this.offsetY * (textureIndex >> 1 & 1);
          } else {
            textureId = textureIndex;
            shiftU = 0;
            shiftV = 0;
          }
        }
        const x = points[i + POINT_STRUCT.X];
        const y = points[i + POINT_STRUCT.Y];
        const w = points[i + POINT_STRUCT.TILE_WIDTH];
        const h = points[i + POINT_STRUCT.TILE_HEIGHT];
        const u = points[i + POINT_STRUCT.U] + shiftU;
        const v = points[i + POINT_STRUCT.V] + shiftV;
        let rotate = points[i + POINT_STRUCT.ROTATE];
        const animX = points[i + POINT_STRUCT.ANIM_X];
        const animY = points[i + POINT_STRUCT.ANIM_Y];
        const animWidth = points[i + POINT_STRUCT.ANIM_COUNT_X] || 1024;
        const animHeight = points[i + POINT_STRUCT.ANIM_COUNT_Y] || 1024;
        const animXEncoded = animX + animWidth * 2048;
        const animYEncoded = animY + animHeight * 2048;
        const animDivisor = points[i + POINT_STRUCT.ANIM_DIVISOR];
        const alpha = points[i + POINT_STRUCT.ALPHA];
        let u0;
        let v0;
        let u1;
        let v1;
        let u2;
        let v2;
        let u3;
        let v3;
        if (rotate === 0) {
          u0 = u;
          v0 = v;
          u1 = u + w;
          v1 = v;
          u2 = u + w;
          v2 = v + h;
          u3 = u;
          v3 = v + h;
        } else {
          let w2 = w / 2;
          let h2 = h / 2;
          if (rotate % 4 !== 0) {
            w2 = h / 2;
            h2 = w / 2;
          }
          const cX = u + w2;
          const cY = v + h2;
          rotate = groupD8.add(rotate, groupD8.NW);
          u0 = cX + w2 * groupD8.uX(rotate);
          v0 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          u1 = cX + w2 * groupD8.uX(rotate);
          v1 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          u2 = cX + w2 * groupD8.uX(rotate);
          v2 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          u3 = cX + w2 * groupD8.uX(rotate);
          v3 = cY + h2 * groupD8.uY(rotate);
        }
        arr[sz++] = x;
        arr[sz++] = y;
        arr[sz++] = u0;
        arr[sz++] = v0;
        arr[sz++] = u + eps;
        arr[sz++] = v + eps;
        arr[sz++] = u + w - eps;
        arr[sz++] = v + h - eps;
        arr[sz++] = animXEncoded;
        arr[sz++] = animYEncoded;
        arr[sz++] = textureId;
        arr[sz++] = animDivisor;
        arr[sz++] = alpha;
        arr[sz++] = x + w;
        arr[sz++] = y;
        arr[sz++] = u1;
        arr[sz++] = v1;
        arr[sz++] = u + eps;
        arr[sz++] = v + eps;
        arr[sz++] = u + w - eps;
        arr[sz++] = v + h - eps;
        arr[sz++] = animXEncoded;
        arr[sz++] = animYEncoded;
        arr[sz++] = textureId;
        arr[sz++] = animDivisor;
        arr[sz++] = alpha;
        arr[sz++] = x + w;
        arr[sz++] = y + h;
        arr[sz++] = u2;
        arr[sz++] = v2;
        arr[sz++] = u + eps;
        arr[sz++] = v + eps;
        arr[sz++] = u + w - eps;
        arr[sz++] = v + h - eps;
        arr[sz++] = animXEncoded;
        arr[sz++] = animYEncoded;
        arr[sz++] = textureId;
        arr[sz++] = animDivisor;
        arr[sz++] = alpha;
        arr[sz++] = x;
        arr[sz++] = y + h;
        arr[sz++] = u3;
        arr[sz++] = v3;
        arr[sz++] = u + eps;
        arr[sz++] = v + eps;
        arr[sz++] = u + w - eps;
        arr[sz++] = v + h - eps;
        arr[sz++] = animXEncoded;
        arr[sz++] = animYEncoded;
        arr[sz++] = textureId;
        arr[sz++] = animDivisor;
        arr[sz++] = alpha;
      }
      vertexBuf.update(arr);
    }
    renderer.geometry.bind(vb, shader);
    renderer.geometry.draw(DRAW_MODES.TRIANGLES, rectsCount * 6, 0);
  }
  /**
   * @internal
   * @ignore
   */
  isModified(anim) {
    if (this.modificationMarker !== this.pointsBuf.length || anim && this.hasAnimatedTile) {
      return true;
    }
    return false;
  }
  /**
   * This will pull forward the modification marker.
   *
   * @internal
   * @ignore
   */
  clearModify() {
    this.modificationMarker = this.pointsBuf.length;
  }
  /** @override */
  _calculateBounds() {
    const { minX, minY, maxX, maxY } = this.tilemapBounds;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  /** @override */
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      return this.tilemapBounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  /** @override */
  destroy(options) {
    super.destroy(options);
    this.destroyVb();
  }
  /**
   * Deprecated signature for {@link Tilemap.tile tile}.
   *
   * @deprecated Since @pixi/tilemap 3.
   */
  addFrame(texture, x, y, animX, animY) {
    this.tile(
      texture,
      x,
      y,
      {
        animX,
        animY
      }
    );
    return true;
  }
  /**
   * Deprecated signature for {@link Tilemap.tile tile}.
   *
   * @deprecated Since @pixi/tilemap 3.
   */
  // eslint-disable-next-line max-params
  addRect(textureIndex, u, v, x, y, tileWidth, tileHeight, animX = 0, animY = 0, rotate = 0, animCountX = 1024, animCountY = 1024, animDivisor = 1, alpha = 1) {
    return this.tile(
      textureIndex,
      x,
      y,
      {
        u,
        v,
        tileWidth,
        tileHeight,
        animX,
        animY,
        rotate,
        animCountX,
        animCountY,
        animDivisor,
        alpha
      }
    );
  }
};
var CompositeTilemap = class _CompositeTilemap extends Container {
  /** The hard limit on the number of tile textures used in each tilemap. */
  /**
   * The animation frame vector.
   *
   * Animated tiles have four parameters - `animX`, `animY`, `animCountX`, `animCountY`. The textures
   * of adjacent animation frames are at offset `animX` or `animY` of each other, with `animCountX` per
   * row and `animCountY` per column.
   *
   * The animation frame vector specifies which animation frame texture to use. If the x/y coordinate is
   * larger than the `animCountX` or `animCountY` for a specific tile, the modulus is taken.
   */
  __init() {
    this.tileAnim = null;
  }
  /** The last modified tilemap. */
  __init2() {
    this.lastModifiedTilemap = null;
  }
  __init3() {
    this.modificationMarker = 0;
  }
  __init4() {
    this.shadowColor = new Float32Array([0, 0, 0, 0.5]);
  }
  __init5() {
    this._globalMat = null;
  }
  /**
   * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered
   *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}
   *  will work equivalently.
   */
  constructor(tileset) {
    super();
    _CompositeTilemap.prototype.__init.call(this);
    _CompositeTilemap.prototype.__init2.call(this);
    _CompositeTilemap.prototype.__init3.call(this);
    _CompositeTilemap.prototype.__init4.call(this);
    _CompositeTilemap.prototype.__init5.call(this);
    _CompositeTilemap.prototype.__init6.call(this);
    this.tileset(tileset);
    this.texturesPerTilemap = settings.TEXTURES_PER_TILEMAP;
  }
  /**
   * This will preinitialize the tilesets of the layered tilemaps.
   *
   * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the
   * existing tilemaps. Passing the tileset to the constructor instead is the best practice.
   *
   * @param tileTextures - The list of tile textures that make up the tileset.
   */
  tileset(tileTextures) {
    if (!tileTextures) {
      tileTextures = [];
    }
    const texPerChild = this.texturesPerTilemap;
    const len1 = this.children.length;
    const len2 = Math.ceil(tileTextures.length / texPerChild);
    for (let i = 0; i < Math.min(len1, len2); i++) {
      this.children[i].setTileset(
        tileTextures.slice(i * texPerChild, (i + 1) * texPerChild)
      );
    }
    for (let i = len1; i < len2; i++) {
      const tilemap = new Tilemap(tileTextures.slice(i * texPerChild, (i + 1) * texPerChild));
      tilemap.compositeParent = true;
      tilemap.offsetX = settings.TEXTILE_DIMEN;
      tilemap.offsetY = settings.TEXTILE_DIMEN;
      this.addChild(tilemap);
    }
    return this;
  }
  /** Clears the tilemap composite. */
  clear() {
    for (let i = 0; i < this.children.length; i++) {
      this.children[i].clear();
    }
    this.modificationMarker = 0;
    return this;
  }
  /** Changes the rotation of the last added tile. */
  tileRotate(rotate) {
    if (this.lastModifiedTilemap) {
      this.lastModifiedTilemap.tileRotate(rotate);
    }
    return this;
  }
  /** Changes `animX`, `animCountX` of the last added tile. */
  tileAnimX(offset, count) {
    if (this.lastModifiedTilemap) {
      this.lastModifiedTilemap.tileAnimX(offset, count);
    }
    return this;
  }
  /** Changes `animY`, `animCountY` of the last added tile. */
  tileAnimY(offset, count) {
    if (this.lastModifiedTilemap) {
      this.lastModifiedTilemap.tileAnimY(offset, count);
    }
    return this;
  }
  /** Changes `tileAnimDivisor` value of the last added tile. */
  tileAnimDivisor(divisor) {
    if (this.lastModifiedTilemap) {
      this.lastModifiedTilemap.tileAnimDivisor(divisor);
    }
    return this;
  }
  /**
   * Adds a tile that paints the given tile texture at (x, y).
   *
   * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.
   * @param x - The local x-coordinate of the tile's location.
   * @param y - The local y-coordinate of the tile's location.
   * @param options - Additional options to pass to {@link Tilemap.tile}.
   * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.
   * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.
   * @param [options.tileWidth=texture.orig.width] - The local width of the tile.
   * @param [options.tileHeight=texture.orig.height] - The local height of the tile.
   * @param [options.animX=0] - For animated tiles, this is the "offset" along the x-axis for adjacent
   *      animation frame textures in the base-texture.
   * @param [options.animY=0] - For animated tiles, this is the "offset" along the y-axis for adjacent
   *      animation frames textures in the base-texture.
   * @param [options.rotate=0]
   * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures
   *      per row.
   * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures
   *      per column.
   * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame
   * @param [options.alpha=1] - Tile alpha
   * @return This tilemap, good for chaining.
   */
  tile(tileTexture, x, y, options = {}) {
    let tilemap = null;
    const children = this.children;
    this.lastModifiedTilemap = null;
    if (typeof tileTexture === "number") {
      const childIndex = tileTexture / this.texturesPerTilemap >> 0;
      let tileIndex = 0;
      tilemap = children[childIndex];
      if (!tilemap) {
        tilemap = children[0];
        if (!tilemap)
          return this;
        tileIndex = 0;
      } else {
        tileIndex = tileTexture % this.texturesPerTilemap;
      }
      tilemap.tile(
        tileIndex,
        x,
        y,
        options
      );
    } else {
      if (typeof tileTexture === "string") {
        tileTexture = Texture.from(tileTexture);
      }
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        const tex = child.getTileset();
        for (let j = 0; j < tex.length; j++) {
          if (tex[j] === tileTexture.baseTexture) {
            tilemap = child;
            break;
          }
        }
        if (tilemap) {
          break;
        }
      }
      if (!tilemap) {
        for (let i = children.length - 1; i >= 0; i--) {
          const child = children[i];
          if (child.getTileset().length < this.texturesPerTilemap) {
            tilemap = child;
            child.getTileset().push(tileTexture.baseTexture);
            break;
          }
        }
        if (!tilemap) {
          tilemap = new Tilemap(tileTexture.baseTexture);
          tilemap.compositeParent = true;
          tilemap.offsetX = settings.TEXTILE_DIMEN;
          tilemap.offsetY = settings.TEXTILE_DIMEN;
          this.addChild(tilemap);
        }
      }
      tilemap.tile(
        tileTexture,
        x,
        y,
        options
      );
    }
    this.lastModifiedTilemap = tilemap;
    return this;
  }
  renderCanvas(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    const tilemapPlugin = CanvasTileRenderer.getInstance(renderer);
    if (tilemapPlugin && !tilemapPlugin.dontUseTransform) {
      const wt = this.worldTransform;
      renderer.context.setTransform(
        wt.a,
        wt.b,
        wt.c,
        wt.d,
        wt.tx * renderer.resolution,
        wt.ty * renderer.resolution
      );
    }
    const layers = this.children;
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      layer.tileAnim = this.tileAnim;
      layer.renderCanvasCore(renderer);
    }
  }
  render(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    const plugin = renderer.plugins.tilemap;
    const shader = plugin.getShader();
    renderer.batch.setObjectRenderer(plugin);
    this._globalMat = shader.uniforms.projTransMatrix;
    renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);
    shader.uniforms.shadowColor = this.shadowColor;
    shader.uniforms.animationFrame = this.tileAnim || plugin.tileAnim;
    renderer.shader.bind(shader, false);
    const layers = this.children;
    for (let i = 0; i < layers.length; i++) {
      layers[i].renderWebGLCore(renderer, plugin);
    }
  }
  /**
   * @internal
   * @ignore
   */
  isModified(anim) {
    const layers = this.children;
    if (this.modificationMarker !== layers.length) {
      return true;
    }
    for (let i = 0; i < layers.length; i++) {
      if (layers[i].isModified(anim)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @internal
   * @ignore
   */
  clearModify() {
    const layers = this.children;
    this.modificationMarker = layers.length;
    for (let i = 0; i < layers.length; i++) {
      layers[i].clearModify();
    }
  }
  /**
   * @deprecated Since @pixi/tilemap 3.
   * @see CompositeTilemap.tile
   */
  addFrame(texture, x, y, animX, animY, animWidth, animHeight, animDivisor, alpha) {
    return this.tile(
      texture,
      x,
      y,
      {
        animX,
        animY,
        animCountX: animWidth,
        animCountY: animHeight,
        animDivisor,
        alpha
      }
    );
  }
  /**
   * @deprecated @pixi/tilemap 3
   * @see CompositeTilemap.tile
   */
  // eslint-disable-next-line max-params
  addRect(textureIndex, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight) {
    const childIndex = textureIndex / this.texturesPerTilemap >> 0;
    const textureId = textureIndex % this.texturesPerTilemap;
    if (this.children[childIndex] && this.children[childIndex].getTileset()) {
      this.lastModifiedTilemap = this.children[childIndex];
      this.lastModifiedTilemap.addRect(
        textureId,
        u,
        v,
        x,
        y,
        tileWidth,
        tileHeight,
        animX,
        animY,
        rotate,
        animWidth,
        animHeight
      );
    } else {
      this.lastModifiedTilemap = null;
    }
    return this;
  }
  /**
   * Alias for {@link CompositeTilemap.tileset tileset}.
   *
   * @deprecated Since @pixi/tilemap 3.
   */
  __init6() {
    this.setBitmaps = this.tileset;
  }
  /**
   * @deprecated Since @pixi/tilemap 3.
   * @readonly
   * @see CompositeTilemap.texturesPerTilemap
   */
  get texPerChild() {
    return this.texturesPerTilemap;
  }
};
var TextileResource = class _TextileResource extends Resource {
  /** The base-texture that contains all the texture tiles. */
  __init() {
    this.baseTexture = null;
  }
  __init2() {
    this._clearBuffer = null;
  }
  /**
   * @param options - This will default to the "settings" exported by @pixi/tilemap.
   * @param options.TEXTILE_DIMEN - The dimensions of each tile.
   * @param options.TEXTILE_UNITS - The number of texture tiles.
   */
  constructor(options = settings) {
    super(
      options.TEXTILE_DIMEN * 2,
      options.TEXTILE_DIMEN * Math.ceil(options.TEXTILE_UNITS / 2)
    );
    _TextileResource.prototype.__init.call(this);
    _TextileResource.prototype.__init2.call(this);
    const tiles = this.tiles = new Array(options.TEXTILE_UNITS);
    this.doClear = !!options.DO_CLEAR;
    this.tileDimen = options.TEXTILE_DIMEN;
    for (let j = 0; j < options.TEXTILE_UNITS; j++) {
      tiles[j] = {
        dirtyId: 0,
        x: options.TEXTILE_DIMEN * (j & 1),
        y: options.TEXTILE_DIMEN * (j >> 1),
        baseTexture: Texture.WHITE.baseTexture
      };
    }
  }
  /**
   * Sets the texture to be uploaded for the given tile.
   *
   * @param index - The index of the tile being set.
   * @param texture - The texture with the base-texture to upload.
   */
  tile(index, texture) {
    const tile = this.tiles[index];
    if (tile.baseTexture === texture) {
      return;
    }
    tile.baseTexture = texture;
    this.baseTexture.update();
    this.tiles[index].dirtyId = this.baseTexture.dirtyId;
  }
  /** @override */
  bind(baseTexture) {
    if (this.baseTexture) {
      throw new Error("Only one baseTexture is allowed for this resource!");
    }
    this.baseTexture = baseTexture;
    super.bind(baseTexture);
  }
  /** @override */
  upload(renderer, texture, glTexture) {
    const { gl } = renderer;
    const { width, height } = this;
    gl.pixelStorei(
      gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
      texture.alphaMode === void 0 || texture.alphaMode === ALPHA_MODES.UNPACK
    );
    if (glTexture.dirtyId < 0) {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(
        texture.target,
        0,
        texture.format,
        width,
        height,
        0,
        texture.format,
        texture.type,
        null
      );
    }
    const doClear = this.doClear;
    const tiles = this.tiles;
    if (doClear && !this._clearBuffer) {
      this._clearBuffer = new Uint8Array(settings.TEXTILE_DIMEN * settings.TEXTILE_DIMEN * 4);
    }
    for (let i = 0; i < tiles.length; i++) {
      const spr = tiles[i];
      const tex = spr.baseTexture;
      if (glTexture.dirtyId >= this.tiles[i].dirtyId) {
        continue;
      }
      const res = tex.resource;
      if (!tex.valid || !res || !res.source) {
        continue;
      }
      if (doClear && (tex.width < this.tileDimen || tex.height < this.tileDimen)) {
        gl.texSubImage2D(
          texture.target,
          0,
          spr.x,
          spr.y,
          this.tileDimen,
          this.tileDimen,
          texture.format,
          texture.type,
          this._clearBuffer
        );
      }
      gl.texSubImage2D(
        texture.target,
        0,
        spr.x,
        spr.y,
        texture.format,
        texture.type,
        res.source
      );
    }
    return true;
  }
};
function generateSampleSrc(maxTextures) {
  let src = "";
  src += "\n";
  src += "\n";
  src += "if(vTextureId <= -1.0) {";
  src += "\n	color = shadowColor;";
  src += "\n}";
  for (let i = 0; i < maxTextures; i++) {
    src += "\nelse ";
    if (i < maxTextures - 1) {
      src += `if(textureId == ${i}.0)`;
    }
    src += "\n{";
    src += `
	color = texture2D(uSamplers[${i}], textureCoord * uSamplerSize[${i}]);`;
    src += "\n}";
  }
  src += "\n";
  src += "\n";
  return src;
}
function fillSamplers(shader, maxTextures) {
  const sampleValues = [];
  for (let i = 0; i < maxTextures; i++) {
    sampleValues[i] = i;
  }
  shader.uniforms.uSamplers = sampleValues;
  const samplerSize = [];
  for (let i = 0; i < maxTextures; i++) {
    samplerSize.push(1 / 2048);
    samplerSize.push(1 / 2048);
  }
  shader.uniforms.uSamplerSize = samplerSize;
}
function generateFragmentSrc(maxTextures, fragmentSrc) {
  return fragmentSrc.replace(/%count%/gi, `${maxTextures}`).replace(/%forloop%/gi, generateSampleSrc(maxTextures));
}
var tilemapVertexTemplateSrc = `#version 100
precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aFrame;
attribute vec2 aAnim;
attribute float aAnimDivisor;
attribute float aTextureId;
attribute float aAlpha;

uniform mat3 projTransMatrix;
uniform vec2 animationFrame;

varying vec2 vTextureCoord;
varying float vTextureId;
varying vec4 vFrame;
varying float vAlpha;

void main(void)
{
   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vec2 animCount = floor((aAnim + 0.5) / 2048.0);
   vec2 animFrameOffset = aAnim - animCount * 2048.0;
   vec2 currentFrame = floor(animationFrame / aAnimDivisor);
   vec2 animOffset = animFrameOffset * floor(mod(currentFrame + 0.5, animCount));

   vTextureCoord = aTextureCoord + animOffset;
   vFrame = aFrame + vec4(animOffset, animOffset);
   vTextureId = aTextureId;
   vAlpha = aAlpha;
}
`;
var tilemapFragmentTemplateSrc = `#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
varying vec2 vTextureCoord;
varying vec4 vFrame;
varying float vTextureId;
varying float vAlpha;
uniform vec4 shadowColor;
uniform sampler2D uSamplers[%count%];
uniform vec2 uSamplerSize[%count%];

void main(void)
{
   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);
   float textureId = floor(vTextureId + 0.5);

   vec4 color;
   %forloop%
   gl_FragColor = color * vAlpha;
}
`;
var TilemapShader = class _TilemapShader extends Shader {
  __init() {
    this.maxTextures = 0;
  }
  constructor(maxTextures) {
    super(
      new Program(
        tilemapVertexTemplateSrc,
        generateFragmentSrc(maxTextures, tilemapFragmentTemplateSrc)
      ),
      {
        animationFrame: new Float32Array(2),
        uSamplers: [],
        uSamplerSize: [],
        projTransMatrix: new Matrix()
      }
    );
    _TilemapShader.prototype.__init.call(this);
    this.maxTextures = maxTextures;
    fillSamplers(this, this.maxTextures);
  }
};
var TilemapGeometry = class _TilemapGeometry extends Geometry {
  __init2() {
    this.vertSize = 13;
  }
  __init3() {
    this.vertPerQuad = 4;
  }
  __init4() {
    this.stride = this.vertSize * 4;
  }
  __init5() {
    this.lastTimeAccess = 0;
  }
  constructor() {
    super();
    _TilemapGeometry.prototype.__init2.call(this);
    _TilemapGeometry.prototype.__init3.call(this);
    _TilemapGeometry.prototype.__init4.call(this);
    _TilemapGeometry.prototype.__init5.call(this);
    const buf = this.buf = new Buffer(new Float32Array(2), true, false);
    this.addAttribute("aVertexPosition", buf, 0, false, 0, this.stride, 0).addAttribute("aTextureCoord", buf, 0, false, 0, this.stride, 2 * 4).addAttribute("aFrame", buf, 0, false, 0, this.stride, 4 * 4).addAttribute("aAnim", buf, 0, false, 0, this.stride, 8 * 4).addAttribute("aTextureId", buf, 0, false, 0, this.stride, 10 * 4).addAttribute("aAnimDivisor", buf, 0, false, 0, this.stride, 11 * 4).addAttribute("aAlpha", buf, 0, false, 0, this.stride, 12 * 4);
  }
};
var TileRenderer = class _TileRenderer extends ObjectRenderer {
  /** The managing renderer */
  /** The tile animation frame */
  __init() {
    this.tileAnim = [0, 0];
  }
  __init2() {
    this.ibLen = 0;
  }
  // index buffer length
  /** The index buffer for the tilemaps to share. */
  __init3() {
    this.indexBuffer = null;
  }
  /** The shader used to render tilemaps. */
  /**
   * {@link TextileResource} instances used to upload textures batched in tiled groups. This is
   * used only if {@link settings.TEXTURES_PER_TILEMAP} is greater than 1.
   */
  __init4() {
    this.textiles = [];
  }
  /** @param renderer - The managing renderer */
  constructor(renderer) {
    super(renderer);
    _TileRenderer.prototype.__init.call(this);
    _TileRenderer.prototype.__init2.call(this);
    _TileRenderer.prototype.__init3.call(this);
    _TileRenderer.prototype.__init4.call(this);
    this.shader = new TilemapShader(settings.TEXTURES_PER_TILEMAP);
    this.indexBuffer = new Buffer(void 0, true, true);
    this.checkIndexBuffer(2e3);
    this.makeTextiles();
  }
  /**
   * Binds the tile textures to the renderer, and updates the tilemap shader's `uSamplerSize` uniform.
   *
   * If {@link settings.TEXTILE_UNITS}
   *
   * @param renderer - The renderer to which the textures are to be bound.
   * @param textures - The tile textures being bound.
   */
  bindTileTextures(renderer, textures) {
    const len = textures.length;
    const shader = this.shader;
    const maxTextures = settings.TEXTURES_PER_TILEMAP;
    const samplerSize = shader.uniforms.uSamplerSize;
    if (len > settings.TEXTILE_UNITS * maxTextures) {
      return;
    }
    if (settings.TEXTILE_UNITS <= 1) {
      for (let i = 0; i < textures.length; i++) {
        const texture = textures[i];
        if (!texture || !texture.valid) {
          return;
        }
        renderer.texture.bind(textures[i], i);
        samplerSize[i * 2] = 1 / textures[i].realWidth;
        samplerSize[i * 2 + 1] = 1 / textures[i].realHeight;
      }
    } else {
      this.makeTextiles();
      const usedTextiles = Math.ceil(len / settings.TEXTILE_UNITS);
      for (let i = 0; i < len; i++) {
        const texture = textures[i];
        if (texture && texture.valid) {
          const resourceIndex = Math.floor(i / settings.TEXTILE_UNITS);
          const tileIndex = i % settings.TEXTILE_UNITS;
          this.textiles[resourceIndex].tile(tileIndex, texture);
        }
      }
      for (let i = 0; i < usedTextiles; i++) {
        renderer.texture.bind(this.textiles[i].baseTexture, i);
        samplerSize[i * 2] = 1 / this.textiles[i].width;
        samplerSize[i * 2 + 1] = 1 / this.textiles[i].baseTexture.height;
      }
    }
    shader.uniforms.uSamplerSize = samplerSize;
  }
  start() {
  }
  /**
   * @internal
   * @ignore
   */
  createVb() {
    const geom = new TilemapGeometry();
    geom.addIndex(this.indexBuffer);
    geom.lastTimeAccess = Date.now();
    return geom;
  }
  /** @return The {@link TilemapShader} shader that this rendering pipeline is using. */
  getShader() {
    return this.shader;
  }
  destroy() {
    super.destroy();
    this.shader = null;
  }
  checkIndexBuffer(size, _vb = null) {
    const totalIndices = size * 6;
    if (totalIndices <= this.ibLen) {
      return;
    }
    this.ibLen = totalIndices;
    this.indexBuffer.update(createIndicesForQuads(
      size,
      settings.use32bitIndex ? new Uint32Array(size * 6) : void 0
    ));
  }
  /** Makes textile resources and initializes {@link TileRenderer.textiles}. */
  makeTextiles() {
    if (settings.TEXTILE_UNITS <= 1) {
      return;
    }
    for (let i = 0; i < settings.TEXTILE_UNITS; i++) {
      if (this.textiles[i])
        continue;
      const resource = new TextileResource();
      const baseTex = new BaseTexture(resource);
      baseTex.scaleMode = settings.TEXTILE_SCALE_MODE;
      baseTex.wrapMode = WRAP_MODES.CLAMP;
      this.textiles[i] = resource;
    }
  }
};
var pixi_tilemap = {
  CanvasTileRenderer,
  CompositeRectTileLayer: CompositeTilemap,
  CompositeTilemap,
  Constant,
  TextileResource,
  MultiTextureResource: TextileResource,
  RectTileLayer: Tilemap,
  Tilemap,
  TilemapShader,
  TilemapGeometry,
  RectTileShader: TilemapShader,
  RectTileGeom: TilemapGeometry,
  TileRenderer
};
Renderer.registerPlugin("tilemap", TileRenderer);
export {
  CanvasTileRenderer,
  CompositeTilemap as CompositeRectTileLayer,
  CompositeTilemap,
  Constant,
  POINT_STRUCT_SIZE,
  Tilemap as RectTileLayer,
  TextileResource,
  TileRenderer,
  Tilemap,
  TilemapGeometry,
  TilemapShader,
  fillSamplers,
  generateFragmentSrc,
  pixi_tilemap,
  settings
};
/*! Bundled license information:

@pixi/tilemap/lib/pixi-tilemap.es.js:
  (*!
   * @pixi/tilemap - v3.2.2
   * Compiled Fri, 22 Oct 2021 12:27:49 UTC
   *
   * @pixi/tilemap is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   * 
   * Copyright 2019-2020, Ivan Popelyshev, All Rights Reserved
   *)
*/
//# sourceMappingURL=@pixi_tilemap.js.map
