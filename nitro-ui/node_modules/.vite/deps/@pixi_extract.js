import {
  RenderTexture
} from "./chunk-AFWUENJS.js";
import {
  ExtensionType
} from "./chunk-NMEPII5P.js";
import {
  CanvasRenderTarget
} from "./chunk-6F3JVGAM.js";
import "./chunk-MQYHZ4VI.js";
import {
  MSAA_QUALITY
} from "./chunk-GCCTLPNP.js";
import {
  Rectangle
} from "./chunk-GM7ILVO6.js";
import "./chunk-UXIASGQL.js";

// ../node_modules/.pnpm/@pixi+extract@6.5.10_@pixi+constants@6.5.10_@pixi+core@6.5.10_@pixi+math@6.5.10_@pixi+utils@6.5.10/node_modules/@pixi/extract/dist/esm/extract.mjs
var TEMP_RECT = new Rectangle();
var BYTES_PER_PIXEL = 4;
var Extract = (
  /** @class */
  function() {
    function Extract2(renderer) {
      this.renderer = renderer;
    }
    Extract2.prototype.image = function(target, format, quality) {
      var image = new Image();
      image.src = this.base64(target, format, quality);
      return image;
    };
    Extract2.prototype.base64 = function(target, format, quality) {
      return this.canvas(target).toDataURL(format, quality);
    };
    Extract2.prototype.canvas = function(target, frame) {
      var _a = this._rawPixels(target, frame), pixels = _a.pixels, width = _a.width, height = _a.height, flipY = _a.flipY;
      var canvasBuffer = new CanvasRenderTarget(width, height, 1);
      var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
      Extract2.arrayPostDivide(pixels, canvasData.data);
      canvasBuffer.context.putImageData(canvasData, 0, 0);
      if (flipY) {
        var target_1 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
        target_1.context.scale(1, -1);
        target_1.context.drawImage(canvasBuffer.canvas, 0, -height);
        canvasBuffer.destroy();
        canvasBuffer = target_1;
      }
      return canvasBuffer.canvas;
    };
    Extract2.prototype.pixels = function(target, frame) {
      var pixels = this._rawPixels(target, frame).pixels;
      Extract2.arrayPostDivide(pixels, pixels);
      return pixels;
    };
    Extract2.prototype._rawPixels = function(target, frame) {
      var renderer = this.renderer;
      var resolution;
      var flipY = false;
      var renderTexture;
      var generated = false;
      if (target) {
        if (target instanceof RenderTexture) {
          renderTexture = target;
        } else {
          var multisample = renderer.context.webGLVersion >= 2 ? renderer.multisample : MSAA_QUALITY.NONE;
          renderTexture = this.renderer.generateTexture(target, { multisample });
          if (multisample !== MSAA_QUALITY.NONE) {
            var resolvedTexture = RenderTexture.create({
              width: renderTexture.width,
              height: renderTexture.height
            });
            renderer.framebuffer.bind(renderTexture.framebuffer);
            renderer.framebuffer.blit(resolvedTexture.framebuffer);
            renderer.framebuffer.bind(null);
            renderTexture.destroy(true);
            renderTexture = resolvedTexture;
          }
          generated = true;
        }
      }
      if (renderTexture) {
        resolution = renderTexture.baseTexture.resolution;
        frame = frame !== null && frame !== void 0 ? frame : renderTexture.frame;
        flipY = false;
        renderer.renderTexture.bind(renderTexture);
      } else {
        resolution = renderer.resolution;
        if (!frame) {
          frame = TEMP_RECT;
          frame.width = renderer.width;
          frame.height = renderer.height;
        }
        flipY = true;
        renderer.renderTexture.bind(null);
      }
      var width = Math.round(frame.width * resolution);
      var height = Math.round(frame.height * resolution);
      var pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
      var gl = renderer.gl;
      gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      if (generated) {
        renderTexture.destroy(true);
      }
      return { pixels, width, height, flipY };
    };
    Extract2.prototype.destroy = function() {
      this.renderer = null;
    };
    Extract2.arrayPostDivide = function(pixels, out) {
      for (var i = 0; i < pixels.length; i += 4) {
        var alpha = out[i + 3] = pixels[i + 3];
        if (alpha !== 0) {
          out[i] = Math.round(Math.min(pixels[i] * 255 / alpha, 255));
          out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255 / alpha, 255));
          out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255 / alpha, 255));
        } else {
          out[i] = pixels[i];
          out[i + 1] = pixels[i + 1];
          out[i + 2] = pixels[i + 2];
        }
      }
    };
    Extract2.extension = {
      name: "extract",
      type: ExtensionType.RendererPlugin
    };
    return Extract2;
  }()
);
export {
  Extract
};
/*! Bundled license information:

@pixi/extract/dist/esm/extract.mjs:
  (*!
   * @pixi/extract - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/extract is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
*/
//# sourceMappingURL=@pixi_extract.js.map
